OnTranslate
{
	_talk = reference0
	
	if reference1 == "" && reference2 == "" //If this is from the input box
	{ //send input box : no event (ref2) , no special flag (ref1)
		_talk = EVAL('"' + REPLACE(_talk,'"','""') + '"')
	}
	
	if "\![no-autopause]" !_in_ _talk
	{
		_talk = REPLACE(_talk,". ",".\w8\w8 ")
		_talk = REPLACE(_talk,"? ","?\w8\w8 ")
		_talk = REPLACE(_talk,"! ","!\w8\w8 ")
		_talk = REPLACE(_talk,"; ",";\w8 ")
		_talk = REPLACE(_talk,", ",",\w4 ")
		_talk = REPLACE(_talk,"\n\n ","\n\n\w8\w8")
		//_talk = REPLACE(_talk,". ",".\w8\w8 ")
	}
	
	TOSTR(_talk)
}

OnAnchorSelect
{
	if "http://" _in_ reference0 || "https://" _in_ reference0; "\j[""%(reference0)""]"
}

OnKeyPress
{
	if reference0 == "f1"; "\![open,readme]"
	elseif reference0 == "t"; OnAiTalk
	elseif reference0 == "r"; OnLastTalk
}

OnSurfaceRestore : all
{
	if SHIORI3FW.ShellName != Candidate.Shell
	{
		"\1\s[-1]\0\s[-1]\![change,shell,%(Candidate.Shell)]\![set,alpha,100]"
	}
	else
	{
		"\![set,alpha,100]"
		
		if ISFUNC("SurfaceRestore.%(CurrentShell)")
		{
			EVAL("SurfaceRestore.%(CurrentShell)")
		}
		else
		{
			"\1\s[-1]\0\s[0]"
		}
	}
}

OnWindowStateRestore
{
	OnSurfaceRestore
}

On_homeurl
{
	"https://raw.githubusercontent.com/Zichqec/wanted_dead_alive_or_other/refs/heads/main/"
}

FadeIn : all
{
	for _i = 0; _i < 100; _i++
	{
		"\![set,alpha,%(_i)]"
		"\_w[10]"
	}
	"\![set,alpha,100]"
}

FadeOut : all
{
	for _i = 100; _i > 0; _i--
	{
		"\![set,alpha,%(_i)]"
		"\_w[10]"
	}
	"\![set,alpha,0]"
}

//May get more complex later
CurrentShell
{
	SHIORI3FW.ShellName
}

//!!! NOT FOR USE IN QUESTIONS !!!
//It will cause trouble there!!! we'll just have to deal with it. This is ok for randomtalk and things like boot/close/acceptance/rejection though
br
{
	if SHIORI3FW.BalloonName == "SSPデフォルト+"; " \c[char,1]\n"
	else; " "
}

//[character ID, category name, part name, option, on-1/off-0, thumbnail path]
OnNotifyDressupInfo
{
	//every damn time...
	CurrentDressups = IARRAY
	AvailableDressups = IARRAY
	
	foreach reference; _dressup
	{
		_dressup = SPLIT(_dressup,C_BYTE1)
		_temp = "%(_dressup[0])%(C_BYTE1)%(_dressup[1])%(C_BYTE1)%(_dressup[2])"
		if _dressup[4] == "1"; CurrentDressups ,= _temp
		
		_temp += "%(C_BYTE1)%(_dressup[3])"
		AvailableDressups ,= _temp
	}
}

//Send scope as an argument
RandomizeDressups : all
{
	_scope = 0
	if _argv[0] != ""; _scope = _argv[0]
	
	"\p[%(_scope)]"
	
	//Remove all dressups
	foreach CurrentDressups; _dressup
	{
		_dressup = SPLIT(_dressup,C_BYTE1)
		
		if _dressup[0] != _scope; continue
		
		"\![bind,%(_dressup[1]),%(_dressup[2]),0]"
	}
	
	//Get categories for scope
	_categorynames = IARRAY
	_categoryitems = IARRAY
	_categoryopts = IARRAY
	foreach AvailableDressups; _dressup
	{
		_dressup = SPLIT(_dressup,C_BYTE1)
		
		if _dressup[0] != _scope; continue
		
		_index = ASEARCH(_dressup[1],_categorynames)
		if _index == -1
		{
			_index = ARRAYSIZE(_categorynames) //Put at end
			_categorynames[_index] = _dressup[1]
			_categoryitems[_index] = ""
			_categoryopts[_index] = _dressup[3]
		}
		
		if _categoryitems[_index] != ""; _categoryitems[_index] += C_BYTE1
		_categoryitems[_index] += _dressup[2]
	}
	
	//Assign new dressups
	for _i = 0; _i < ARRAYSIZE(_categorynames); _i++
	{
		_category = _categorynames[_i]
		_mustselect = 0
		_multiple = 0
		if "mustselect" _in_ _categoryopts[_i]; _mustselect = 1
		if "multiple" _in_ _categoryopts[_i]; _multiple = 1
		
		_skipchance = 4
		_items = SPLIT(_categoryitems[_i],C_BYTE1)
		
		if !_mustselect //Chance to skip category
		{
			if RAND(_skipchance) == 0; continue
		}
		
		_adding = ""
		if _multiple
		{
			foreach _items; _item
			{
				if RAND(_skipchance) == 0; continue //Chance to skip each item
				
				_adding += "\![bind,%(_category),%(_item),1]"
			}
		}
		
		//If nothing was chosen in a multiple selection, or if it's mustselect
		if _adding == ""; _adding += "\![bind,%(_category),%(ANY(_items)),1]"
		_adding
	}
}

EncodeMorse
{
	_cipherlist = MorseList
	_letterlist = IARRAY
	_codelist = IARRAY
	foreach _cipherlist; _item
	{
		_item = SPLIT(_item,"|")
		_letterlist ,= _item[0]
		_codelist ,= _item[1]
	}
	
	_words = SPLIT(_argv[0]," ")
	_output = ""
	foreach _words; _word
	{
		if _output != ""; _output += " /"
		for _i = 0; _i < STRLEN(_word); _i++
		{
			if _output != ""; _output += " "
			_letter = SUBSTR(_word,_i,1)
			_index = ASEARCH(TOUPPER(_letter),_letterlist)
			
			if _index == -1; _output += "#"
			else; _output += _codelist[_index]
		}
	}
	_output
}

DecodeMorse
{
	_cipherlist = MorseList
	_letterlist = IARRAY
	_codelist = IARRAY
	foreach _cipherlist; _item
	{
		_item = SPLIT(_item,"|")
		_letterlist ,= _item[0]
		_codelist ,= _item[1]
	}
	
	_words = SPLIT(_argv[0],"/")
	_output = ""
	foreach _words; _word
	{
		if _output != ""; _output += " "
		_letters = SPLIT(_word," ")
		foreach _letters; _letter
		{
			_index = ASEARCH(_letter,_codelist)
			_output += _letterlist[_index]
		}
	}
	_output
}

MorseList : array
{
	//To add a new code, just duplicate one of these lines and change the items on either side!
	"A|.-"
	"B|-..."
	"C|-.-."
	"D|-.."
	"E|."
	"F|..-."
	"G|--."
	"H|...."
	"I|.."
	"J|.---"
	"K|-.-"
	"L|.-.."
	"M|--"
	"N|-."
	"O|---"
	"P|.--."
	"Q|--.-"
	"R|.-."
	"S|..."
	"T|-"
	"U|..-"
	"V|...-"
	"W|.--"
	"X|-..-"
	"Y|-.--"
	"Z|--.."
	"0|-----"
	"1|.----"
	"2|..---"
	"3|...--"
	"4|....-"
	"5|....."
	"6|-...."
	"7|--..."
	"8|---.."
	"9|----."
	".|.-.-.-"
	",|--..--"
	"?|..--.."
	"'|.----."
	"/|-..-."
	"(|-.--."
	")|-.--.-"
	":|---..."
	"=|-...-"
	"+|.-.-."
	"-|-....-"
	'"|.-..-.'
	"@|.--.-."
	"!|-.-.--" //Nonstandard, but probably common enough to want
}



/*
	REVISED:
	-1. Collected no responses, act as though this session did not happen (as it likely happened by mistake)
	0. Accepted no candidates, performed no experiment
	1. Not enough candidates
	2. Just let everyone in without checks
	3. Didn't filter well enough
	4. Did ok, decent sample size
	5. Filtered well, excellent sample size
	
	If accepted no candidates: fail for reason 1
	If not met minimum number of candidates: fail for reason 2
	If all candidates have 0 questions asked: fail for reason 3
	If not enough candidates were rejected OR the number of bad decisions is too great: fail for reason 4
	If number of good decisions is decent: succeed for reason 5
	If number of good decisions is very high: succeed for reason 6
	
	Numbers (may be adjusted later):
	Minimum candidates required for an experiment: 5
	Minimum number of candidates to be rejected: 1/3
	Minimum number of good decisions to succeed: 1/2
	Minimum number of good decisions to succeed spectacularly: 2/3
*/

CalculateExperimentSuccess
{
	LOGGING("====================================================================")
	_acceptednum = 0
	_rejectednum = 0
	_michaelnum = 0
	_gooddecisions = 0
	_baddecisions = 0
	_noanswers = 0
	//Don't forget michael lol, he does NOT count towards ANYTHING
	
	foreach PreviousResponses; _response
	{
		_response = SPLIT(_response,CHR(0xFDEF))
		_candidatestatus = _response[0][1,C_BYTE1]
		_answers = SPLIT(_response[1],C_BYTE1)
		
		if _candidatestatus == 0; _rejectednum++
		elseif _candidatestatus == 1; _acceptednum++
		elseif _candidatestatus == 2; _michaelnum++
		//NO MICHAEL ... actually TODO maybe he needs to count as a rejection? But also a good decision... hm!
		//I guess not otherwise he'll really throw things off lol
		
		_asked = 0
		foreach _answers; _answer
		{
			if _answer != "N/A"; _asked++
		}
		
		//10 questions seen at a time, 15 expected N/A
		if _asked == 0; _noanswers++
		
		if _asked >= 6; _gooddecisions++
		else; _baddecisions++
	}
	
	AcceptedCandidatesLast = _acceptednum
	RejectedCandidatesLast = _rejectednum
	MichaelLast = _michaelnum
	
	_nonmichaels = _acceptednum + _rejectednum
	
	if _acceptednum == 0; 0 //"Accepted no candidates"
	elseif _acceptednum < 5; 1 //"Not enough candidates"
	elseif _acceptednum == _noanswers; 2 //"No filtering"
	else
	{
		_rejectionsrequired = CEIL(TOREAL(_nonmichaels) / 3)
		_gooddecisionsrequired = CEIL(TOREAL(_nonmichaels) / 2)
		_verygooddecisionsrequired = (CEIL(TOREAL(_nonmichaels) / 3) * 2) //2/3 I hope?
		
		LOGGING("_gooddecisions: %(_gooddecisions)")
		LOGGING("_gooddecisionsrequired: %(_gooddecisionsrequired)")
		LOGGING("_verygooddecisionsrequired: %(_verygooddecisionsrequired)")
		if _rejectednum >= _rejectionsrequired && _gooddecisions >= _gooddecisionsrequired
		{
			if _gooddecisions >= _verygooddecisionsrequired; 5 //"Excellent filtering"
			else; 4 //"Good filtering"
		}
		else; 3 //"Poor filtering"
	}
}

ExperimentSuccessLabel
{
	switch _argv[0]
	{
		"Accepted no candidates"
		"Not enough candidates"
		"No filtering"
		"Poor filtering"
		"Good filtering"
		"Excellent filtering"
	}
}

emdash
{
	"\f[name,calibri]—\f[name,default]"
}

//—————————————————————————————— Right click menu links ——————————————————————————————

//Takes an array of alternating names and urls, and formats them for use with the right click menu
FormatLinks : all
{
	for _i = 0; _i < ARRAYSIZE(_argv); _i++
	{
		_argv[_i] //Add the link/title
		//Alternate between adding %ASC(1) or %ASC(2)
		if _i % 2 == 1; "%(CHR(2))"
		else; "%(CHR(1))"
	}
}

On_sakura.recommendsites
{
	FormatLinks(recommendsites_sakura)
}

recommendsites_sakura : array
{
	"Link label";	"https://link.example.com/link/to/whatever/here/"
}

On_sakura.portalsites 
{
	FormatLinks(portalsites_sakura)
}

//These are the websites linked in the second option of the sakura's right click menu. Same as above
portalsites_sakura : array
{
	"Another link label";	"https://link.example.com/link/to/whatever/here/again/"
	"A third link label";	"https://link.example.com/link/to/whatever/a/third/time/you/can/add/as/many/as/you/want/"
}